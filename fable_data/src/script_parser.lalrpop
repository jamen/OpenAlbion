use alloc::string::String;
use alloc::borrow::ToOwned;

use core::str::FromStr;

use crate::{Field,Value,Accessor,Item,Call,Key};

grammar;

match {
    r"(?i)NULL",
} else {
    r"[a-zA-Z_][a-zA-Z0-9_]*",
    _
}

// Script is a list of items
pub(crate) Script = <Item*>;

// An item is a field or call
Item: Item = {
    // A field is a key, path, and value. The path and value are optional.
    <key:Key> <path:Accessor*> <value:Value?> ";" =>
        Item::Field(Field { key, path, value }),

    <name:Ident> "(" <mut params:(<Value> ",")*> <last:Value?> ")" ";" => {
        params.extend(last);
        Item::Call(Call { name, params })
    },
}

Key: Key = {
    "NewRegion" => Key::NewRegion,
    "NewThing" => Key::NewThing,
    // TODO: Rest of the keys
    <Ident> => Key::Other(<>),
}

Accessor: Accessor = {
    "." <Ident> => Accessor::Dot(<>),
    "[" <Value> "]" => Accessor::Box(<>),
}

Value: Value = {
    // Integer or UID
    <s:r"[0-9]+"> => i64::from_str(s).map(|x| Value::Integer(x))
        .or_else(|_| u64::from_str(s).map(|x| Value::Uid(x)))
        .unwrap(),

    // Float
    <r"[0-9]+\.[0-9]+"> => Value::Float(f32::from_str(<>).unwrap()),

    // Bool
    <r"(?i)TRUE|FALSE"> => Value::Bool(bool::from_str(&<>.to_lowercase()).unwrap()),

    // Null
    r"(?i)NULL" => Value::Null,

    // Call
    <name:Ident> "(" <mut params:(<Value> ",")*> <last:Value?> ")" => {
        params.extend(last);
        Value::Call(Call { name, params })
    },

    // String
    // Fable probably doesn't support anything fancy for strings, so meh.
    <r#""[^"]*""#> => Value::String(<>.to_owned()),

    // Ident
    <Ident> => Value::Ident(<>),
}

Ident: String = <r"[a-zA-Z_][a-zA-Z0-9_]*"> => <>.to_owned();